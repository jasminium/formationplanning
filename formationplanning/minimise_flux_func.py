"""
FormationPlanning
Copyright (C) 2020 : Northumbria University
            Author : John Hartley

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import numpy as np
import math
from scipy.optimize import minimize
from scipy.optimize import BFGS
from scipy.optimize import NonlinearConstraint
from formationplanning.trajectory import map_to_time
from formationplanning.trajectory import interpolate_trajectory
import matplotlib.animation as animation


target = []
x_t = []
area_t = []
phi_t = []

q = []
dl = 1
r = None
rf = None
qf = None


s = 5

n_obs = 0

def callback(xk, state):
    """Memorise the state at each iteration of the minimisation."""
    # save the positions
    x_t.append(xk)
    # save the current flux
    #phi_t.append(flux(xk))
    return False

def cons_f(x):
    """"Function to measure the independence of the connecting edges of the surface."""
    p = x.reshape((4, 3), order='F')

    a = p[0] - p[1]
    b = p[1] - p[2]
    c = p[2] - p[3]
    d = p[3] - p[0]
    e = p[0] - p[2]
    f = p[1] - p[3]

    return [
        a.dot(a),
        b.dot(b),
        c.dot(c),
        d.dot(d),
        e.dot(e),
        f.dot(f)
    ]

def v(x):

    p = x.reshape((4, 3), order='F')

    l = 5
    # shift surface 10 in positive x direction
    target = np.array([
        [20, 0, 0 + 10],
        [20, l, 0 + 10],
        [20, l, l + 10],
        [20, 0, l + 10]])

    obs = np.array([
        [10, 0, 0],
        [10, l, 0],
        [10, l, l],
        [10, 0, l]])

    # the target is a point in n dim space
    t = target.flatten(order='F')
    o = obs.flatten(order='F')

    v = -1 / np.linalg.norm(x - t)
    v += 1 / np.linalg.norm(x - o) / 5

    return v

def minimise_flux(surface, l):
    """
        Minimise the flux generated by a target through a connected surface.

    Parameters
    ----------
    targets : np.array((n, 3))
        array of targets or single target with Numpy single dimension.

    surface : np.array((4, 3))
        four 3d points which define a surface.

    l: float (optional)
        length of contraint for the sidelength of the open surface. For multiple targets
        this is calculated internally.

    Returns
    -------
    x_t: np.array((iterations, 4, 3))
        Iteration history of the surface.
    phi_t: np.array((iteration))
        Iteration history of the flux through the surface.
    """
    global q
    global r
    global x_t
    global phi_t

    # Reset surface, and flux history.
    x_t = []
    phi_t = []

    x0 = surface.flatten(order='F')

    cons = np.array([l**2, l**2, l**2, l**2, 2 * l**2, 2 * l**2 ])

    nonlinear_constraint_1 = NonlinearConstraint(cons_f, cons, cons, jac='2-point', hess=BFGS())

    minimize(
        v, x0=x0,
        method='trust-constr',
        options={
                #'xtol': 1e-12,
                 'maxiter': 20000,
                 'disp':True,
                 'verbose': 2,
                },
        #jac=jacobian_flux,
        callback=callback,
        constraints=[
            # sides must have some minimum length
            nonlinear_constraint_1
        ])

    x_j = np.reshape(x_t, (len(x_t), 4, 3), order='F')

    return x_j, phi_t


if __name__ == '__main__':
    
    l = 5

    surface = np.array([
    [0, 0, 0],
    [0, l, 0],
    [0, l, l],
    [0, 0, l]])

    surface = np.array([surface[1], surface[0], surface[3], surface[2]])

    x_t, phi_t = minimise_flux(surface, l)

    t = map_to_time(x_t)
    # interpolate the trajectory at every 0.1 seconds.
    t_int, x_t_int = interpolate_trajectory(t, x_t)

    obs = np.array([
        [10, 0, 0],
        [10, l, 0],
        [10, l, l],
        [10, 0, l]])

    """
    from mayavi import mlab

    mlab.figure(1, bgcolor=(1, 1, 1), fgcolor=(0, 0, 0), size=(1000, 1000))
    maps = ['spring', 'summer', 'winter', 'autumn']

    for i in range(4):
        path = x_t[:, i]
        t = np.arange(path.shape[0])
        s = mlab.plot3d(path[:, 0], path[:, 1], path[:, 2], t, tube_radius=0.1, colormap=maps[i])

    obs = np.array([
        [10, 0, 0],
        [10, l, 0],
        [10, l, l],
        [10, 0, l]])

    mlab.axes(color=(0,0,0), extent=(0, 20, 0, 20, 0, 20))
    mlab.show()

    """
    from mpl_toolkits.mplot3d import Axes3D
    import matplotlib.pyplot as plt

    fig = plt.figure(1, figsize=(10,10))
    ax = fig.add_subplot(111, projection='3d')

    maps = ['spring', 'summer', 'winter', 'autumn']
    colors = ['darkviolet', 'blue', 'aquamarine', 'cornflowerblue']

    for i in range(4):
        path = x_t_int[:, i]
        c = np.arange(path.shape[0])
        mappable = ax.scatter(path[:, 0], path[:, 1], path[:, 2], cmap=maps[i], c=c, marker='o', depthshade=False)

    ax.scatter(obs[:, 0], obs[:, 1], obs[:, 2],  marker='o', depthshade=False, color='pink')


    # animation
    fig = plt.figure(2)
    ax = fig.add_subplot(111, projection='3d')

    xmin = x_t_int[:, :, 0].min()
    xmax = x_t_int[:, :, 0].max()
    ymin = x_t_int[:, :, 1].min()
    ymax = x_t_int[:, :, 1].max()
    zmin = x_t_int[:, :, 2].min()
    zmax = x_t_int[:, :, 2].max()

    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    ax.set_zlim(zmin, zmax)

    def update_graph(j):
        ax.clear()
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(ymin, ymax)
        ax.set_zlim(zmin, zmax)
        ax.set_xlabel('x [m]')
        ax.set_ylabel('y [m]')
        ax.set_zlabel('z [m]')

        #graph_1 = ax.plot_trisurf(vertices[j, :, 0], vertices[j, :, 1], vertices[j, :, 2], color='blue')
        #graph_2 = ax.plot_trisurf(followers[j, :, 0], followers[j, :, 1], followers[j, :, 2], color='green')

        for i in range(4):
            path = x_t_int[:, i]
            c = np.arange(path.size)
            ax.scatter(path[j, 0], path[j, 1], path[j, 2], color=colors[i])

        ax.scatter(obs[:, 0], obs[:, 1], obs[:, 2], color='pink', marker='o', depthshade=False)


    ani = animation.FuncAnimation(fig, update_graph, x_t_int.shape[0],
                                interval=100, blit=False)

    plt.show()

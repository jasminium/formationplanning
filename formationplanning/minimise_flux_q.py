"""
FormationPlanning
Copyright (C) 2020 : Northumbria University
            Author : John Hartley

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import numpy as np
import math
from scipy.optimize import minimize
from scipy.optimize import BFGS
from scipy.optimize import NonlinearConstraint

target = []
x_t = []
area_t = []
phi_t = []

q = []
dl = 1
r = None
rf = None
qf = None


s = 5

n_obs = 0

def flux_through_triangle(A, B, C, P):
    """
        Evaluate the solid angle illuminating a triangle.

        The triangle is defined by defined A, B, C by a point P.
    """

    """Gets and prints the spreadsheet's header columns

    Parameters
    ----------
    A : np.array((3))
        Vertex A of the triangle

    B : np.array((3))
        Vertex B of the triangle

    C : np.array((3))
        Vertex C of the triangle

    P : np.array((3))
        Source

    Returns
    -------
    float
        The value of the solid angle.
    """
    a = P - A
    b = P - B
    c = P - C

    ab = np.cross(a, b)

    num = dot_3_vec(ab, c)

    a_m = np.sqrt(dot_3_vec(a, a))
    b_m = np.sqrt(dot_3_vec(b, b))
    c_m = np.sqrt(dot_3_vec(c, c))

    de = a_m * b_m * c_m + dot_3_vec(a, b) * c_m + dot_3_vec(a, c) * b_m + dot_3_vec(b, c) * a_m
    phi = np.arctan2(num, de) * 2

    return phi

def dot_3_vec(a, b):
    return np.sum(a*b, axis=1)

def flux(x):
    """
        Evaluate the Flux through the surface x.

    Parameters
    ----------
    x : np.array((12))
        Fortran order list of coordinates for the surface

    Returns
    -------
    float
        The value of the solid angle.
    """

    # map the solution space back to the vector points.
    p = x.reshape((4, 3), order='F')

    # Order of vertices [r2, r6, r7, r3]

    # define the triangulation for the surface.
    triangle_list = [
        # r2, r6, r7
        [0, 2, 1],
        # r2, r7, r3
        [0, 3, 2]
    ]

    # total flux through triangulated surface
    phi = 0

    # evaluate the flux through each triangle.
    for i, tri in enumerate(triangle_list):
        # get triangle vertices
        r1 = p[tri[0]]
        r2 = p[tri[1]]
        r3 = p[tri[2]]

        r1_s = np.vstack([r1]*qf.size)
        r2_s = np.vstack([r2]*qf.size)
        r3_s = np.vstack([r3]*qf.size)

        phi_v = qf * flux_through_triangle(r1_s, r2_s, r3_s, rf)
        phi += phi_v.sum()
    
    return phi


def jacobian_flux(x):
    """
        Evaluate the jacobian of the flux through the surface x.

        Evaluating the jacobian is significantly faster than using
        an automatic differentiation provided by numpy.

        The jacobian is evaluated using a central finite difference

    Parameters
    ----------
    x : np.array((12))
        Fortran order list of coordinates for the surface

    Returns
    -------
    np.array(12)
        The flux jacobian
    """

    # jacobian
    j = np.zeros(12)

    dx = 1e-8

    for i, x_i in enumerate(x):

        # evaluate the derivate using a
        # central finite difference.

        x_i_u = x_i + dx
        x_i_l = x_i - dx

        x[i] = x_i_u
        flux_u = flux(x)

        x[i] = x_i_l
        flux_l = flux(x)

        # derivative
        j_x = (flux_u - flux_l) / 2 / dx
        j[i] = j_x

        # recover original position
        x[i] = x_i

    return j

def callback(xk, state):
    """Memorise the state at each iteration of the minimisation."""
    # save the positions
    x_t.append(xk)
    # save the current flux
    phi_t.append(flux(xk))
    return False

def cons_f(x):
    """"Function to measure the independence of the connecting edges of the surface."""
    p = x.reshape((4, 3), order='F')

    a = p[0] - p[1]
    b = p[1] - p[2]
    c = p[2] - p[3]
    d = p[3] - p[0]

    return [
        a.dot(a),
        b.dot(b),
        c.dot(c),
        d.dot(d)
    ]

def obj(x):
    """
        Weighted objective function for flux and area

    Parameters
    ----------
    x : np.array((12))
        Fortran order list of coordinates for the surface.

    Returns
    -------
    float
        scalar mapping
    """
    return flux(x)

def minimise_flux(charge, surface, dx=1, l=None):
    """
        Minimise the flux generated by a target through a connected surface.

    Parameters
    ----------
    targets : np.array((n, 3))
        array of targets or single target with Numpy single dimension.

    surface : np.array((4, 3))
        four 3d points which define a surface.

    l: float (optional)
        length of contraint for the sidelength of the open surface. For multiple targets
        this is calculated internally.

    Returns
    -------
    x_t: np.array((iterations, 4, 3))
        Iteration history of the surface.
    phi_t: np.array((iteration))
        Iteration history of the flux through the surface.
    """
    global q
    global r
    global x_t
    global phi_t
    global dl
    global rf
    global qf

    # Reset surface, and flux history.
    x_t = []
    phi_t = []
    q = charge
    dl = dx

    r = np.zeros((q.shape[0], q.shape[1], q.shape[2], 3))
    # evaluate the flux through the triangle from all the charges in.
    for n in range(q.shape[0]):
        for o in range(q.shape[1]):
            for p in range(q.shape[2]):
                # qi * flux
                r[n, o, p] = np.array((n * dl, o * dl, p * dl))

    # cache flattened
    rf = np.resize(r, (r.shape[0] * r.shape[1] * r.shape[2], 3))
    qf = q.flatten()

    # "Starting value guess"
    x0 = surface.flatten(order='F')

    nonlinear_constraint_1 = NonlinearConstraint(cons_f, l**2, l**2, jac='2-point', hess=BFGS())

    minimize(
        obj, x0=x0,
        method='trust-constr',
        #tol=1e-8,
        options={'maxiter': 1000,
                 'disp':True,
                 'verbose': 2,
                },
        jac=jacobian_flux,
        callback=callback,
        constraints=[
                    # sides must have some minimum length
                    nonlinear_constraint_1
        ])

    x_j = np.reshape(x_t, (len(x_t), 4, 3), order='F')

    return x_j, phi_t
